import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { map } from 'rxjs/operators';

import { Post } from './post.model';

@Injectable({
  providedIn: 'root'
})
export class PostsService {

  constructor(private http: HttpClient) { }

  onCreateAndStorePosts(title: string, content: string) {
    const postData: Post = {title, content};
    this.http
    .post<{name: string}>(
      'https://angular-maxi-http.firebaseio.com/posts.json',
      postData
    )
    .subscribe(responseData => {
      console.log(responseData);
    });
  }

  onFetchPosts() {
    // tslint:disable-next-line:max-line-length
    // pipe as you learned is a method that allows you to funnel your observable data through multiple operators before they reach the subscribe method. The map operator allows us to get some data and return new data which is then automatically re-wrapped into an observable so that we can still subscribe to it, if it would not be wrapped into an observable again, we could not subscribe.
    return this.http
      // tslint:disable-next-line:max-line-length
      // between the angled brackets, you store the type which this response will actually return as a body once it's done. So it's the response body type which is stored here and that will then automatically be handled by the Angular HttpClient and TypeScript understands this and now knows that the response data will have this type format as you can tell and this is also available on post requests, it's available on all requests, you can use these angled brackets to add this extra piece of information which is totally optional but recommended and helpful about the data you're getting back. yukarida post request te yaptik. name dememizin sebebi tekrar request yaptigimizda console da gorduk 'name' property
      .get<{[key: string]: Post}>('https://angular-maxi-http.firebaseio.com/posts.json')
      // tslint:disable-next-line:max-line-length
      .pipe(map(responseData => {// that should now return the converted response data and here the idea is that we return an array of posts instead of an object with that cryptic key which then holds our actual post. Now to convert a Javascript object which we have here to an array, we have to manually loop through all the keys and create a new array.
        const postsArray: Post[] = [];
        for (const key in responseData) {
          // tslint:disable-next-line:max-line-length
          // if you're using a for/in loop where you check if response data has key as its own property so that you're not trying to access the property of some prototype
          if (responseData.hasOwnProperty(key)) {
            // tslint:disable-next-line:max-line-length
            // This will pull out all the key-value pairs of that nested object we're accessing here and let's close this with curly braces too because this now allows me to also add one new key-value pair to that object we're adding to posts array and that should be an ID field which actually stores the key because that key here, that cryptic string is a perfect ID and it is a unique ID generated by Firebase.
            postsArray.push({...responseData[key], id: key});
          }
        }
        return postsArray;
      }));
  }

  onDeletePosts() {
    // tslint:disable-next-line:max-line-length
    // if I want to be informed about that deletion process in the component, I will return my observable here and I will not subscribe here in the service but instead now in the app component, in onClearPosts, I can reach out to the post service and call delete posts and since this returns an observable, we now have to subscribe here.
    return this.http.delete('https://angular-maxi-http.firebaseio.com/posts.json');
  }
}
